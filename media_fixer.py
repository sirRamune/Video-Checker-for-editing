#!/usr/bin/env python3
"""
Media Fixer
Utilizing various checks from Media Analyzer, performs fixes.
"""

import json
import os
import subprocess
from pathlib import Path
from typing import List, Dict, Any
from dotenv import load_dotenv

from bitrate_logic import calculate_encoding_parameters
from utils import extract_media_info


def load_config():
    """Load configuration from .env file."""
    load_dotenv()

    # Get file paths generated by video_analyzer
    input_file = os.getenv('EDITABLE_FILES_OUTPUT', 'editable_files.json')

    # Get output folder for encoded files
    encoded_output_folder = os.getenv('ENCODED_FILES_OUTPUT', './optimized-media/')

    # Get video output values
    output_crf = int(os.getenv('OUTPUT_CRF', '22'))
    output_encoder = os.getenv('OUTPUT_ENCODER', 'libx265')
    output_preset = os.getenv('OUTPUT_PRESET', 'medium')

    return input_file, encoded_output_folder, output_crf, output_encoder, output_preset


def load_media_data(input_file: str) -> List[Dict[str, Any]]:
    """Load media data from the analyzer output JSON."""
    media_data = []
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            media_data = json.load(f)
        print(f"Loaded {len(media_data)} media file(s) from {input_file}")
    except FileNotFoundError:
        print(f"Error: {input_file} not found. Run media_analyzer.py first.")
    except json.JSONDecodeError as e:
        print(f"Error: Failed to parse JSON from {input_file}: {e}")
    return media_data


def remove_defaults(media_path: str, track_ids: List[int]) -> int:
    """
    Run command to remove default flags from specified audio and subtitle tracks.

    Args:
        media_path: Path to the media file
        track_ids: List of track IDs to remove default flags from

    Returns:
        Return code from mkvpropedit command
    """
    cmd = ["mkvpropedit", media_path]

    for track_id in track_ids:
        cmd += ["--edit", f"track:{track_id}", "--set", "flag-default=0"]

    result = subprocess.run(cmd, check=True)
    returncode = result.returncode

    if returncode != 0:
        error_msg = f"Failed with return code {returncode}"
        print(f"  ✗ {error_msg}")
        raise Exception(error_msg)


def process_mkvmerge(
    input_path: Path,
    output_path: Path
) -> None:
    """
    Run mkvmerge to refresh metadata of video.
    
    Args:
        input_path: Path to input video file
        output_path: Path to output video file

    Returns:
        Return code from mkvmerge command
    """
    cmd = [
        "mkvmerge",
        "-o", str(output_path),
        str(input_path)
    ]

    print("Running mkvmerge:")
    print(" ".join(cmd))

    result = subprocess.run(cmd, check=True)
    returncode = result.returncode

    if returncode != 0:
        error_msg = f"Failed with return code {returncode}"
        print(f"  ✗ {error_msg}")
        raise Exception(error_msg)


def encode_video_crf(
    input_path: Path,
    output_path: Path,
    output_crf: int,
    output_encoder: str,
    output_preset: str,
    maxrate: int,
    bufsize: int
) -> None:
    """
    Encode video with CRF (Constant Rate Factor).

    Args:
        input_path: Path to input video file
        output_path: Path to output video file
        target_bitrate: Target bitrate in bits per second
        maxrate: Maximum bitrate in bits per second
        bufsize: Buffer size in bits per second
        encoder: Video encoder codec (libx265, libx264, etc.)
        preset: FFmpeg preset (ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow)

    Returns:
        Return code from ffmpeg command
    """
    # Convert bitrates from bps to kbps for ffmpeg
    maxrate_kbps = maxrate // 1000
    bufsize_kbps = bufsize // 1000

    cmd = [
        "ffmpeg",
        "-y",
        "-i", str(input_path),
        "-map", "0",
        "-c:v", output_encoder,
        "-crf", str(output_crf),
        "-b:v", "0",
        "-maxrate", f"{maxrate_kbps}k",
        "-bufsize", f"{bufsize_kbps}k",
        "-preset", output_preset,
        "-c:a", "copy",
        "-c:s", "copy",
        str(output_path)
    ]

    print("Running FFmpeg:")
    print(" ".join(cmd))

    result = subprocess.run(cmd, check=True)
    returncode = result.returncode

    if returncode != 0:
        error_msg = f"Failed with return code {returncode}"
        print(f"  ✗ {error_msg}")
        raise Exception(error_msg)


def process_entry_optimization(
    input_path: Path,
    output_path: Path,
    output_crf: int,
    output_encoder: str,
    output_preset: str,
    video_tracks: Dict[str, Any]
) -> None:
    """
    Run all optimization process for a file
    From encoding to even replacing the original file with optimization
    
    Args:
        input_file: Path to input video file
        output_file: Path to output video file

    Returns:
        Return code from mkvmerge command
    """
    # Get file_path
    file_path = str(input_path)

    # Get video track info
    if not video_tracks:
        raise Exception(f"{file_path} doesn't contain any video tracks")

    video_track = video_tracks[0]  # Use first video track

    # Get optimization data for entry
    width = video_track.get('width')
    height = video_track.get('height')
    framerate = video_track.get('framerate')

    # Calculate encoding parameters using bitrate_logic
    encoding_params = calculate_encoding_parameters(width, height, framerate, output_encoder)
    maxrate = encoding_params['maxrate']
    bufsize = encoding_params['bufsize']

    print(f"Processing bitrate optimization: {file_path}")
    print(f"  Target bitrate: {encoding_params['target_bitrate'] / 1_000_000:.2f} Mbps")
    print(f"  Encoder: {output_encoder}")
    print(f"  Output: {output_path}")
    print(f"  Preset: {output_preset}")

    encode_video_crf(
        input_path,
        output_path,
        output_crf,
        output_encoder,
        output_preset,
        maxrate,
        bufsize
    )


def process_default_removal (
    file_path: str
) -> None:
    # Obtain updated media_info
    media_info = extract_media_info(file_path)

    # Obtain audio and subtitle tracks
    tracks = media_info.get('audio_tracks', []) + media_info.get('subtitle_tracks', [])

    # Check if it contains any track
    if not tracks:
        raise Exception(f"{file_path} doesn't contain any audio or subtitle tracks")

    # Collect track IDs from audio and subtitle tracks
    track_ids = []

    for track in tracks:
        track_ids.append(track.get('track_id'))

    print(f"Processing default track removal: {file_path}")
    print(f"  Track IDs: {track_ids}")

    remove_defaults(file_path, track_ids)


def process_entry(
        entry: Dict[str, Any],
        output_folder: Path,
        output_crf: int, 
        output_encoder: str, 
        output_preset: str
    ) -> Dict[str, Any]:
    """
    Process each file according to media_analyzer response.

    Args:
        media_data: Dictionary with entry data
    """
    # Reset list of things to do
    needs_bitrate_optimization = False
    needs_default_removal = False

    # Obtain entry data
    file_path = entry.get('file_path')
    checks = entry.get('checks', [])
    media_info = entry.get('media_info', {})

    # Obtain input_path and output_path
    input_path = Path(file_path)
    output_path = output_folder / input_path.name

    # Check list of checks
    for check in checks:
        check_type = check.get('type', '')
        is_editable = check.get('editable', False)

        if is_editable and 'bitrate reduction' in check_type.lower():
            needs_bitrate_optimization = True

        if is_editable and 'default' in check_type.lower():
            needs_default_removal = True

    try:
        # TODO: Get missing subs
        if not needs_bitrate_optimization and not needs_default_removal: 
            print(f"{file_path} is missing subs")

        # Process bitrate optimization
        if needs_bitrate_optimization:
            process_entry_optimization(
                input_path,
                output_path,
                output_crf,
                output_encoder,
                output_preset,
                media_info.get('video_tracks', [])
            )

            # Remove source file
            os.remove(input_path)

            # Update metadata and save output at source file path
            process_mkvmerge(
                output_path,
                input_path
            )
            
            # Delete file in output directory
            os.remove(output_path)

        # Process default removal
        if needs_default_removal or needs_bitrate_optimization:
            process_default_removal(file_path)

        print()
        return {'file_path': file_path}
    except Exception as e:
        error_msg = str(e)
        print(f"  ✗ {error_msg}")
        # Clean up output file if it exists
        if input_path.exists() and output_path.exists():
            output_path.unlink()
        return {'file_path': file_path, 'error': error_msg}


def main():
    """Main function."""

    print("Media Fixer")
    print("=" * 70)
    print()

    # Get configuration
    input_file, encoded_output_folder, output_crf, output_encoder, output_preset = load_config()

    # Create output folder if it doesn't exist
    output_path_dir = Path(encoded_output_folder)
    output_path_dir.mkdir(parents=True, exist_ok=True)

    # Load media data
    media_data = load_media_data(input_file)

    if not media_data:
        print("No media files to process.")
        return

    fixed_files = []
    failed_files = []

    # Process each entry
    for entry in media_data:
        result = process_entry(entry, output_path_dir, output_crf, output_encoder, output_preset)

        if "error" in result:
            failed_files.append(result)
        else:
            fixed_files.append(result)

    # Summary
    print("=" * 70)
    print("Summary:")
    print(f"  Fixed: {len(fixed_files)}")
    print(f"  Failed: {len(failed_files)}")

    if failed_files:
        print("\nFailed files:")
        for file in failed_files:
            print(f"  - {file.get('file_path', '')}")


if __name__ == "__main__":
    main()
