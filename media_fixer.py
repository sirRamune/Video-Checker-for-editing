#!/usr/bin/env python3
"""
Media Fixer
Utilizing various checks from Media Analyzer, performs fixes.
"""

import json
import os
import subprocess
from pathlib import Path
from typing import List, Dict, Any
from dotenv import load_dotenv

from bitrate_logic import calculate_encoding_parameters


def load_config():
    """Load configuration from .env file."""
    load_dotenv()

    # Get file paths generated by video_analyzer
    input_file = os.getenv('EDITABLE_FILES_OUTPUT', 'editable_files.json')

    # Get output folder for encoded files
    encoded_output_folder = os.getenv('ENCODED_FILES_OUTPUT', './optimized-media/')

    # Get video output values
    output_crf = int(os.getenv('OUTPUT_CRF', '23'))
    output_encoder = os.getenv('OUTPUT_ENCODER', 'libx265')
    output_preset = os.getenv('OUTPUT_PRESET', 'medium')

    return input_file, encoded_output_folder, output_crf, output_encoder, output_preset


def load_media_data(input_file: str) -> List[Dict[str, Any]]:
    """Load media data from the analyzer output JSON."""
    media_data = []
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            media_data = json.load(f)
        print(f"Loaded {len(media_data)} media file(s) from {input_file}")
    except FileNotFoundError:
        print(f"Error: {input_file} not found. Run media_analyzer.py first.")
    except json.JSONDecodeError as e:
        print(f"Error: Failed to parse JSON from {input_file}: {e}")
    return media_data


def find_defaults_to_remove(media_data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Find files that need default track removal based on checks.

    Returns a list of dictionaries with file_path and track_ids to process.
    """
    files_to_fix = []

    for entry in media_data:
        file_path = entry.get('file_path')
        checks = entry.get('checks', [])
        media_info = entry.get('media_info', {})

        # Check if any default-related check is editable
        needs_fix = False
        for check in checks:
            check_type = check.get('type', '')
            is_editable = check.get('editable', False)

            if is_editable and ('default' in check_type.lower()):
                needs_fix = True
                break

        if needs_fix:
            # Collect track IDs from audio and subtitle tracks
            track_ids = []

            for audio_track in media_info.get('audio_tracks', []):
                track_ids.append(audio_track.get('track_id'))

            for subtitle_track in media_info.get('subtitle_tracks', []):
                track_ids.append(subtitle_track.get('track_id'))

            files_to_fix.append({
                'file_path': file_path,
                'track_ids': track_ids
            })

    return files_to_fix


def remove_defaults(media_path: str, track_ids: List[int]) -> int:
    """
    Run command to remove default flags from specified audio and subtitle tracks.

    Args:
        media_path: Path to the media file
        track_ids: List of track IDs to remove default flags from

    Returns:
        Return code from mkvpropedit command
    """
    cmd = ["mkvpropedit", media_path]

    for track_id in track_ids:
        cmd += ["--edit", f"track:{track_id}", "--set", "flag-default=0"]

    result = subprocess.run(cmd, check=True)
    return result.returncode


def process_default_removal(media_data: List[Dict[str, Any]]) -> None:
    """
    Process default removal for all files.

    Returns a dictionary with processing results:
    - total: Total files processed
    - fixed: List of successfully fixed files
    - failed: List of failed files with error messages
    """
    fixed_files = []
    failed_files = []

    # Find files that need default removal
    files_to_fix = find_defaults_to_remove(media_data)

    if not files_to_fix:
        print("No files need default flag removal.")
        return

    print(f"\nFound {len(files_to_fix)} file(s) that need default removal:")
    for entry in files_to_fix:
        print(f"  - {entry['file_path']}")
    print()

    print(f"Processing {len(files_to_fix)} file(s)...")
    print()

    for entry in files_to_fix:
        file_path = entry['file_path']
        track_ids = entry['track_ids']

        print(f"Processing: {file_path}")
        print(f"  Track IDs: {track_ids}")
        try:
            returncode = remove_defaults(file_path, track_ids)
            if returncode == 0:
                print(f"  ✓ Successfully removed defaults")
                fixed_files.append(file_path)
            else:
                error_msg = f"Failed with return code {returncode}"
                print(f"  ✗ {error_msg}")
                failed_files.append({'file_path': file_path, 'error': error_msg})
        except subprocess.CalledProcessError as e:
            error_msg = str(e)
            print(f"  ✗ Error: {error_msg}")
            failed_files.append({'file_path': file_path, 'error': error_msg})
        except Exception as e:
            error_msg = str(e)
            print(f"  ✗ Unexpected error: {error_msg}")
            failed_files.append({'file_path': file_path, 'error': error_msg})
        print()

    # Summary
    print("=" * 70)
    print("Default audio and subtitle summary:")
    print(f"  Fixed: {len(fixed_files)}")
    print(f"  Failed: {len(failed_files)}")

    if failed_files:
        print("\nFailed files:")
        for file in failed_files:
            print(f"  - {file.get('file_path', '')}")
        

def find_bitrate_optimization(media_data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Find files that need bitrate optimization based on checks.

    Returns a list of dictionaries with file info and encoding parameters.
    """
    files_to_optimize = []

    for entry in media_data:
        file_path = entry.get('file_path')
        checks = entry.get('checks', [])
        media_info = entry.get('media_info', {})

        # Check if bitrate reduction is editable
        for check in checks:
            check_type = check.get('type', '')
            is_editable = check.get('editable', False)

            if is_editable and 'bitrate reduction' in check_type.lower():
                # Get video track info
                video_tracks = media_info.get('video_tracks', [])
                if video_tracks:
                    video_track = video_tracks[0]  # Use first video track

                    width = video_track.get('width')
                    height = video_track.get('height')
                    framerate = video_track.get('framerate')
                    current_bitrate = video_track.get('bitrate')

                    # Calculate encoding parameters using bitrate_logic
                    encoding_params = calculate_encoding_parameters(
                        width, height, framerate
                    )

                    files_to_optimize.append({
                        'file_path': file_path,
                        'width': width,
                        'height': height,
                        'framerate':framerate,
                        'current_bitrate': current_bitrate,
                        'target_bitrate': encoding_params['target_bitrate'],
                        'maxrate': encoding_params['maxrate'],
                        'bufsize': encoding_params['bufsize'],
                        'encoder': encoding_params['encoder']
                    })
                break

    return files_to_optimize


def process_mkvmerge(
    input_path: Path,
    output_path: Path
) -> int:
    """
    Run mkvmerge to refresh metadata of video.
    
    Args:
        input_path: Path to input video file
        output_path: Path to output video file

    Returns:
        Return code from mkvmerge command
    """
    cmd = [
        "mkvmerge",
        "-o", str(output_path),
        str(input_path)
    ]

    print("Running mkvmerge:")
    print(" ".join(cmd))

    result = subprocess.run(cmd, check=True)
    return result.returncode


def encode_video_crf(
    input_path: Path,
    output_path: Path,
    output_crf: int,
    output_encoder: str,
    output_preset: str,
    maxrate: int,
    bufsize: int
) -> int:
    """
    Encode video with CRF (Constant Rate Factor).

    Args:
        input_path: Path to input video file
        output_path: Path to output video file
        target_bitrate: Target bitrate in bits per second
        maxrate: Maximum bitrate in bits per second
        bufsize: Buffer size in bits per second
        encoder: Video encoder codec (libx265, libx264, etc.)
        preset: FFmpeg preset (ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow)

    Returns:
        Return code from ffmpeg command
    """
    # Convert bitrates from bps to kbps for ffmpeg
    maxrate_kbps = maxrate // 1000
    bufsize_kbps = bufsize // 1000

    cmd = [
        "ffmpeg",
        "-y",
        "-i", str(input_path),
        "-map", "0",
        "-c:v", output_encoder,
        "-crf", output_crf,
        "-b:v", "0",
        "-maxrate", f"{maxrate_kbps}k",
        "-bufsize", f"{bufsize_kbps}k",
        "-preset", output_preset,
        "-c:a", "copy",
        "-c:s", "copy",
        str(output_path)
    ]

    print("Running FFmpeg:")
    print(" ".join(cmd))

    result = subprocess.run(cmd, check=True)
    return result.returncode


def process_entry_optimization(
    input_path: Path,
    output_path: Path,
    output_crf: int,
    output_encoder: str,
    output_preset: str,
    entry: Dict[str, Any]
) -> int:
    """
    Run all optimization process for a file
    From encoding to even replacing the original file with optimization
    
    Args:
        input_file: Path to input video file
        output_file: Path to output video file

    Returns:
        Return code from mkvmerge command
    """
    try:
        # Encode file into output directory
        returncode = encode_video_crf(
            input_path,
            output_path,
            output_crf,
            output_encoder,
            output_preset,
            entry['maxrate'],
            entry['bufsize'],
            entry['encoder']
        )
        if returncode != 0:
            return returncode
        
        # Remove source file
        os.remove(input_path)

        # Update metadata and save output at source file path
        returncode = process_mkvmerge(
            output_path,
            input_path
        )
        if returncode != 0:
            return returncode
        
        # Delete file in output directory
        os.remove(output_path)

        return 0

    except subprocess.CalledProcessError as e:
        raise e
    except Exception as e:
        raise e


def process_bitrate_optimization(
    media_data: List[Dict[str, Any]],
    output_folder: str,
    output_crf: int,
    output_encoder: str,
    output_preset: str
) -> None:
    """
    Process bitrate optimization for all files that need it.

    Args:
        media_data: List of media file entries
        output_folder: Folder where optimized files will be saved
    """
    fixed_files = []
    failed_files = []

    # Create output folder if it doesn't exist
    output_path_dir = Path(output_folder)
    output_path_dir.mkdir(parents=True, exist_ok=True)

    # Find files that need bitrate optimization
    files_to_optimize = find_bitrate_optimization(media_data)

    if not files_to_optimize:
        print("No files need bitrate optimization.")
        return

    print(f"\nFound {len(files_to_optimize)} file(s) that need bitrate optimization:")
    for entry in files_to_optimize:
        print(entry)
        current_bitrate = entry['current_bitrate'] / 1_000_000
        target_bitrate = entry['target_bitrate'] / 1_000_000
        print(f"  - {entry['file_path']}")
        print(f"    {entry['width']}x{entry['height']}@{entry['framerate']}fps")
        print(f"    Current: {current_bitrate:.2f} Mbps → Target: {target_bitrate:.2f} Mbps")
        print(f"    Encoder: {entry['encoder']}")
    print()

    print(f"Processing {len(files_to_optimize)} file(s)...")
    print(f"Output folder: {output_folder}")
    print()

    for entry in files_to_optimize:
        file_path = entry['file_path']
        input_path = Path(file_path)

        # Create output path in output folder with same filename
        output_path = output_path_dir / input_path.name

        print(f"Processing: {file_path}")
        print(f"  Target bitrate: {entry['target_bitrate'] / 1_000_000:.2f} Mbps")
        print(f"  Encoder: {entry['encoder']}")
        print(f"  Output: {output_path}")
        try:
            returncode = process_entry_optimization(
                input_path,
                output_path,
                output_crf,
                output_encoder,
                output_preset,
                entry
            )

            if returncode == 0:
                print(f"  ✓ Successfully encoded")
                fixed_files.append(file_path)
            else:
                error_msg = f"Failed with return code {returncode}"
                print(f"  ✗ {error_msg}")
                failed_files.append({'file_path': file_path, 'error': error_msg})
                # Clean up output file if it exists
                if input_path.exists() and output_path.exists():
                    output_path.unlink()
        except subprocess.CalledProcessError as e:
            error_msg = str(e)
            print(f"  ✗ Error: {error_msg}")
            failed_files.append({'file_path': file_path, 'error': error_msg})
            # Clean up output file if it exists
            if input_path.exists() and output_path.exists():
                output_path.unlink()
        except Exception as e:
            error_msg = str(e)
            print(f"  ✗ Unexpected error: {error_msg}")
            failed_files.append({'file_path': file_path, 'error': error_msg})
            # Clean up output file if it exists
            if input_path.exists() and output_path.exists():
                output_path.unlink()
        print()

    # Summary
    print("=" * 70)
    print("Bitrate optimization summary:")
    print(f"  Fixed: {len(fixed_files)}")
    print(f"  Failed: {len(failed_files)}")

    if failed_files:
        print("\nFailed files:")
        for file in failed_files:
            print(f"  - {file.get('file_path', '')}")


def main():
    """Main function."""

    print("Media Fixer")
    print("=" * 70)
    print()

    # Get configuration
    input_file, encoded_output_folder, output_crf, output_encoder, output_preset = load_config()

    # Load media data
    media_data = load_media_data(input_file)

    if not media_data:
        print("No media files to process.")
        return

    # Process default removal
    process_default_removal(media_data)

    print()

    # Process bitrate optimization
    process_bitrate_optimization(media_data, encoded_output_folder, output_crf, output_encoder, output_preset)


if __name__ == "__main__":
    main()
