#!/usr/bin/env python3
"""
Media Fixer
Utilizing various checks from Media Analyzer, performs fixes.
"""

import json
import os
import subprocess
from typing import List, Dict, Any
from dotenv import load_dotenv


def load_config():
    """Load configuration from .env file."""
    load_dotenv()

    # Get file paths generated by video_analyzer
    input_file = os.getenv('EDITABLE_FILES_OUTPUT', 'editable_files.json')

    return input_file


def load_media_data(input_file: str) -> List[Dict[str, Any]]:
    """Load media data from the analyzer output JSON."""
    media_data = []
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            media_data = json.load(f)
        print(f"Loaded {len(media_data)} media file(s) from {input_file}")
    except FileNotFoundError:
        print(f"Error: {input_file} not found. Run media_analyzer.py first.")
    except json.JSONDecodeError as e:
        print(f"Error: Failed to parse JSON from {input_file}: {e}")
    return media_data


def find_defaults_to_remove(media_data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Find files that need default track removal based on checks.

    Returns a list of dictionaries with file_path and track_ids to process.
    """
    files_to_fix = []

    for entry in media_data:
        file_path = entry.get('file_path')
        checks = entry.get('checks', [])
        media_info = entry.get('media_info', {})

        # Check if any default-related check is editable
        needs_fix = False
        for check in checks:
            check_type = check.get('type', '')
            is_editable = check.get('editable', False)

            if is_editable and ('default' in check_type.lower()):
                needs_fix = True
                break

        if needs_fix:
            # Collect track IDs from audio and subtitle tracks
            track_ids = []

            for audio_track in media_info.get('audio_tracks', []):
                track_ids.append(audio_track.get('track_id'))

            for subtitle_track in media_info.get('subtitle_tracks', []):
                track_ids.append(subtitle_track.get('track_id'))

            files_to_fix.append({
                'file_path': file_path,
                'track_ids': track_ids
            })

    return files_to_fix


def remove_defaults(media_path: str, track_ids: List[int]) -> int:
    """
    Run command to remove default flags from specified audio and subtitle tracks.

    Args:
        media_path: Path to the media file
        track_ids: List of track IDs to remove default flags from

    Returns:
        Return code from mkvpropedit command
    """
    cmd = ["mkvpropedit", media_path]

    for track_id in track_ids:
        cmd += ["--edit", f"track:{track_id}", "--set", "flag-default=0"]

    result = subprocess.run(cmd, check=True)
    return result.returncode


def process_default_removal(media_data: List[Dict[str, Any]]) -> None:
    """
    Process default removal for all files.

    Returns a dictionary with processing results:
    - total: Total files processed
    - fixed: List of successfully fixed files
    - failed: List of failed files with error messages
    """
    fixed_files = []
    failed_files = []

    # Find files that need default removal
    files_to_fix = find_defaults_to_remove(media_data)

    if not files_to_fix:
        print("No files need default flag removal.")
        return

    print(f"\nFound {len(files_to_fix)} file(s) that need default removal:")
    for entry in files_to_fix:
        print(f"  - {entry['file_path']}")
    print()

    print(f"Processing {len(files_to_fix)} file(s)...")
    print()

    for entry in files_to_fix:
        file_path = entry['file_path']
        track_ids = entry['track_ids']

        print(f"Processing: {file_path}")
        print(f"  Track IDs: {track_ids}")
        try:
            returncode = remove_defaults(file_path, track_ids)
            if returncode == 0:
                print(f"  ✓ Successfully removed defaults")
                fixed_files.append(file_path)
            else:
                error_msg = f"Failed with return code {returncode}"
                print(f"  ✗ {error_msg}")
                failed_files.append({'file_path': file_path, 'error': error_msg})
        except subprocess.CalledProcessError as e:
            error_msg = str(e)
            print(f"  ✗ Error: {error_msg}")
            failed_files.append({'file_path': file_path, 'error': error_msg})
        except Exception as e:
            error_msg = str(e)
            print(f"  ✗ Unexpected error: {error_msg}")
            failed_files.append({'file_path': file_path, 'error': error_msg})
        print()

    # Summary
    print("=" * 70)
    print("Default audio and subtitle summary:")
    print(f"  Fixed: {len(fixed_files)}")
    print(f"  Failed: {len(failed_files)}")

    if failed_files:
        print("\nFailed files:")
        for file in failed_files:
            print(f"  - {file.get('file_path', '')}")
        


def main():
    """Main function."""

    print("Media Fixer")
    print("=" * 70)
    print()

    # Get configuration
    input_file = load_config()

    # Load media data
    media_data = load_media_data(input_file)

    if not media_data:
        print("No media files to process.")
        return

    # Process all files and get results
    process_default_removal(media_data)


if __name__ == "__main__":
    main()
