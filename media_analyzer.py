#!/usr/bin/env python3
"""
Media Analyzer
Extracts media information from video files and performs various checks.
"""

import json
import os
from pathlib import Path
from typing import List, Dict, Any, Optional
from pymediainfo import MediaInfo
from dotenv import load_dotenv

from bitrate_logic import calculate_suggested_video_bitrate, format_bitrate
from utils import get_array_from_env_and_file, normalize_language


def load_config():
    """Load configuration from .env file."""
    load_dotenv()

    # Get acceptable difference for bitrate
    acceptable_difference = float(os.getenv('ACCEPTABLE_DIFFERENCE', '10.0'))

    # Get str and file path for needed subs
    needed_subs_str = os.getenv('NEEDED_SUBS', '')
    needed_subs_file = os.getenv('NEEDED_SUBS_FILE', 'needed_subs.txt')

    # Get file paths generated by video_scanner
    input_file = os.getenv('OUTPUT_FILE', 'video_files.txt')

    # Get paths to generate analysis outputs
    output_file = os.getenv('ANALYSIS_OUTPUT', 'media_analysis.json')
    editable_output = os.getenv('EDITABLE_FILES_OUTPUT', 'editable_files.json')

    return acceptable_difference, needed_subs_str, needed_subs_file, input_file, output_file, editable_output


def load_video_files(input_file: str) -> List[str]:
    """Load video file paths from the scanner output."""
    video_files = []
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line:
                    video_files.append(line)
        print(f"Loaded {len(video_files)} video file(s) from {input_file}")
    except FileNotFoundError:
        print(f"Error: {input_file} not found. Run video_scanner.py first.")
    return video_files


def extract_media_info(file_path: str) -> Optional[Dict[str, Any]]:
    """Extract media information from a video file."""
    try:
        media_info = MediaInfo.parse(file_path)

        # Extract general info
        general = media_info.general_tracks[0] if media_info.general_tracks else None

        # Extract video tracks
        video_tracks = []
        for track in media_info.video_tracks:
            video_tracks.append({
                "track_id": track.track_id,
                "stream_order": track.stream_order,
                "format": track.format,
                "codec_id": track.codec_id,
                "width": track.width,
                "height": track.height,
                "framerate": float(track.frame_rate) if track.frame_rate else None,
                "bitrate": track.bit_rate,
                "bit_depth": track.bit_depth,
                "default": track.default if hasattr(track, 'default') else None,
                "forced": track.forced if hasattr(track, 'forced') else None,
            })

        # Extract audio tracks
        audio_tracks = []
        for track in media_info.audio_tracks:
            audio_tracks.append({
                "track_id": track.track_id,
                "stream_order": track.stream_order,
                "format": track.format,
                "codec_id": track.codec_id,
                "channels": track.channel_s,
                "sampling_rate": track.sampling_rate,
                "bitrate": track.bit_rate,
                "language": track.language if hasattr(track, 'language') else None,
                "title": track.title if hasattr(track, 'title') else None,
                "default": track.default if hasattr(track, 'default') else None,
                "forced": track.forced if hasattr(track, 'forced') else None,
            })

        # Extract subtitle tracks
        subtitle_tracks = []
        for track in media_info.text_tracks:
            subtitle_tracks.append({
                "track_id": track.track_id,
                "stream_order": track.stream_order,
                "format": track.format,
                "codec_id": track.codec_id,
                "language": track.language if hasattr(track, 'language') else None,
                "title": track.title if hasattr(track, 'title') else None,
                "default": track.default if hasattr(track, 'default') else None,
                "forced": track.forced if hasattr(track, 'forced') else None,
            })

        return {
            "file_path": file_path,
            "file_size": general.file_size if general else None,
            "duration": general.duration if general else None,
            "format": general.format if general else None,
            "video_tracks": video_tracks,
            "audio_tracks": audio_tracks,
            "subtitle_tracks": subtitle_tracks,
        }

    except FileNotFoundError:
        print(f"Warning: {file_path} not found")
    except PermissionError as e:
        print(f"Permission denied from {file_path}: {e}")
    except Exception as e:
        print(f"Error extracting media info from {file_path}: {e}")
        return None


def check_video_bitrate_reduction(media_data: Dict[str, Any], acceptable_difference: float) -> Dict[str, Any]:
    """Check if video bitrate can be reduced."""
    check_type = "Video bitrate reduction"

    if not media_data.get("video_tracks"):
        return {
            "type": check_type,
            "editable": False,
            "reason": "No video tracks found"
        }

    if len(media_data.get("video_tracks")) > 1:
        return {
            "type": check_type,
            "editable": False,
            "reason": "More than 1 video track found"
        }

    # Check the first video track
    video = media_data["video_tracks"][0]

    if not all([video.get("width"), video.get("height"), video.get("framerate"), video.get("bitrate"), video.get("format")]):
        return {
            "type": check_type,
            "editable": False,
            "reason": "Missing video information (width, height, framerate, bitrate, or format)"
        }

    suggested_bitrate = calculate_suggested_video_bitrate(
        width=video["width"],
        height=video["height"],
        framerate=video["framerate"],
        encoder=video["format"]
    )

    current_bitrate = video.get("bitrate")

    try:
        bitrate_difference = (current_bitrate - suggested_bitrate) / current_bitrate * 100
    except ZeroDivisionError:
        bitrate_difference = 100.0

    editable = bitrate_difference > acceptable_difference

    return {
        "type": check_type,
        "editable": editable,
        "current_bitrate": current_bitrate,
        "suggested_bitrate": suggested_bitrate,
        "bitrate_difference": bitrate_difference,
        "reason": f"Current video exceeds suggestion by {bitrate_difference:.2f}%" if editable
        else "Current bitrate is acceptable"
    }


def check_track_defaults(media_data: Dict[str, Any]) -> Dict[str, Any]:
    """Check if there's an audio or subtitle track set as default."""
    tracks = media_data.get("audio_tracks", []) + media_data.get("subtitle_tracks", [])
    check_type = "Audio or subtitle tracks set as default"

    if not tracks:
        return {
            "type": check_type,
            "editable": False,
            "reason": "No audio or subtitle tracks found"
        }

    has_default = False
    for track in tracks:
        if track.get("default") == "Yes":
            has_default = True

    return {
        "type": check_type,
        "editable": has_default,
        "has_default": has_default,
        "reason": f"There's an audio or subtitle track set as default" if has_default else f"There's NO audio or subtitle track set as default"
    }


def check_missing_subs(media_data: Dict[str, Any], needed_subs: List[str]) -> Dict[str, Any]:
    """Check if there's a sub track missing."""
    sub_tracks = media_data.get("subtitle_tracks", [])
    check_type = "Missing subtitle tracks"

    missing_subs = []

    for sub in needed_subs:
        matches = 0
        for track in sub_tracks:
            if normalize_language(track.get('language', '')) == sub:
                matches += 1
        if matches == 0:
            missing_subs.append(sub)

    has_missing_subs = len(missing_subs) > 0

    return {
        "type": check_type,
        "editable": has_missing_subs,
        "has_missing_subs": has_missing_subs,
        "missing_subs": missing_subs,
        "reason": f"There's missing subtitle tracks " if has_missing_subs else f"There's NO missing subtitle track"
    }


def analyze_file(file_path: str, acceptable_difference: float, needed_subs: List[str]) -> Optional[Dict[str, Any]]:
    """Analyze a single video file."""
    print(f"Analyzing: {file_path}")

    if not os.path.exists(file_path):
        print(f"  Warning: File not found")
        return None

    # Extract media info
    media_data = extract_media_info(file_path)
    if not media_data:
        return None

    # Perform checks
    analysis = {
        "file_path": file_path,
        "media_info": media_data,
        "checks": [
            check_video_bitrate_reduction(media_data, acceptable_difference),
            check_track_defaults(media_data),
            check_missing_subs(media_data, needed_subs)
        ]
    }

    return analysis


def save_analysis_json(analyses: List[Dict[str, Any]], output_file: str):
    """Save all analyses to a JSON file."""
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(analyses, f, indent=2, default=str)

    print(f"\nAll files analysis saved to: {output_file}")


def save_editable_files_json(analyses: List[Dict[str, Any]], output_file: str):
    """Save files that need editing to a separate JSON file."""
    editable_files = [
        analysis for analysis in analyses
        if any(checks.get("editable") for checks in analysis.get("checks", []))
    ]

    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(editable_files, f, indent=2, default=str)

    print(f"Editable files list saved to: {output_file}")
    print(f"  Total files needing editing: {len(editable_files)}")


def print_summary(analyses: List[Dict[str, Any]]):
    """Print a summary of the analysis."""
    print("\n" + "=" * 70)
    print("ANALYSIS SUMMARY")
    print("=" * 70)

    total = len(analyses)

    editables_counts = {}

    for analysis in analyses:
        if analysis.get("checks"):
            for check in analysis.get("checks"):
                check_type = check.get("type")
                is_editable = check.get("editable")

                if is_editable:
                    editables_counts[check_type] = {
                        "type": check_type,
                        "count": editables_counts.get(check_type, {}).get("count", 0) + 1
                    }

    print(f"Total files analyzed: {total}")

    for editable_count in editables_counts:
        print(f"  {editables_counts[editable_count].get('type')}: {editables_counts[editable_count].get('count')}")

    print("=" * 70)


def main():
    """Main function."""

    print("Media Analyzer")
    print("=" * 70)
    print()

    # Get configuration
    acceptable_difference, needed_subs_str, needed_subs_file, input_file, output_file, editable_output = load_config()

    # Load video files
    video_files = load_video_files(input_file)

    if not video_files:
        print("No video files to analyze.")
        return
    
    needed_subs = get_array_from_env_and_file(needed_subs_str, needed_subs_file, 'needed sub')
    print(needed_subs)

    # Analyze each file
    analyses = []
    for video_file in video_files:
        analysis = analyze_file(video_file, acceptable_difference, needed_subs)
        if analysis:
            analyses.append(analysis)

    # Save results
    if analyses:
        save_analysis_json(analyses, output_file)
        save_editable_files_json(analyses, editable_output)
        print_summary(analyses)
    else:
        print("\nNo files were successfully analyzed.")


if __name__ == "__main__":
    main()
